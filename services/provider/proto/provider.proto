syntax = "proto3";
package provider;

import "google/protobuf/descriptor.proto";

option go_package = "./;providerpb";


// OCSProvider holds the RPC methods that the OCS consumer can use to communicate with remote OCS provider cluster
service OCSProvider {
  // OnboardConsumer RPC call to validate the consumer and create StorageConsumer
  // resource on the StorageProvider cluster
  rpc OnboardConsumer (OnboardConsumerRequest)
  returns (OnboardConsumerResponse) {}

  // GetDesiredClientState RPC call to generate the desired state of the client
  rpc GetDesiredClientState(GetDesiredClientStateRequest)
  returns (GetDesiredClientStateResponse){}
  // OffboardConsumer RPC call to delete StorageConsumer CR on the storage provider cluster.
  rpc OffboardConsumer (OffboardConsumerRequest)
  returns (OffboardConsumerResponse) {}

  rpc ReportStatus(ReportStatusRequest)
  returns (ReportStatusResponse){}

  // PeerStorageCluster RPC call to Peer the local Storage Cluster to the remote
  rpc PeerStorageCluster(PeerStorageClusterRequest)
  returns (PeerStorageClusterResponse) {}

  rpc RequestMaintenanceMode(RequestMaintenanceModeRequest)
  returns (RequestMaintenanceModeResponse) {}

  // GetStorageClientsInfo RPC call to get StorageClientInfo for Peer Storage Client
  rpc GetStorageClientsInfo(StorageClientsInfoRequest)
  returns (StorageClientsInfoResponse) {}

  // GetBlockPoolsInfo RPC call to get BlockPoolInfo for Peer Storage Cluster
  rpc GetBlockPoolsInfo(BlockPoolsInfoRequest)
  returns (BlockPoolsInfoResponse) {}

  // Notify RPC call for action on for client cluster
  rpc Notify(NotifyRequest)
  returns (NotifyResponse) {}
}

// OnboardConsumerRequest holds the required information to validate the consumer and create StorageConsumer
// resource on the StorageProvider cluster
message OnboardConsumerRequest{
    // onboardingTicket authenticates the storage consumer cluster
    string onboardingTicket = 1;
    // consumerName is the name of the consumer that is used to create the storageConsumer resource
    string consumerName = 2;
    // clientOperatorVersion is the semver version of ocs-client-operator
    string clientOperatorVersion = 3;
    string clientPlatformVersion = 4;
    // ocs-client-operator deployed namespace
    string clientOperatorNamespace = 5;
    // clientID is the k8s UID of storageClient
    string clientID = 6;
    // clientName is the name of the connected storageclient
    string clientName = 7;
    // clusterID is the id of the openshift cluster
    string clusterID = 8;
    // clusterName is the name of the openshift cluster
    string clusterName = 9;
}

// OnboardConsumerResponse holds the response for OnboardConsumer API request
message OnboardConsumerResponse{
    // K8s UID (UUID) of the consumer cluster
    string storageConsumerUUID = 1;
}

// GetDesiredClientStateRequest holds the information required generate the desired state for connecting to storage consumer
message GetDesiredClientStateRequest{
  // K8s UID of the storage consumer
  string storageConsumerUUID = 1;
}

// KubeObject holds information about a kube object needed for its reconciliation by the 
// client operator
message KubeObject {
    // Bytes holds the serialized bytes of the kube object
    bytes bytes  = 1;
}

// RbdDriverRequirements holds the desired spec of the rbd driver
message RbdDriverRequirements {
    // topologyDomainLables are the list of topology that needs to be set in nodeplugin
    repeated string topologyDomainLables = 1;
    // hostNetwork setting for controller plugin
    optional bool ctrlPluginHostNetwork = 2;
}

message CephFsDriverRequirements {
    // hostNetwork setting for controller plugin
    optional bool ctrlPluginHostNetwork = 1;
}

message NfsDriverRequirements {
    // hostNetwork setting for controller plugin
    optional bool ctrlPluginHostNetwork = 1;
}

// ExternalEndpointConfig holds an external endpoint info/config (e.g. NooBaa S3, NooBaa IAM, RGW S3 etc)
// that the client may expose via a reverse proxy for the Object Browser.
message ExternalEndpointConfig {
    // path the reverse proxy exposes for connecting to this endpoint (must be unique)
    string exposeAs = 1;
    // route or URL of the endpoint
    string endpointUrl = 2;
}

// GetDesiredClientStateResponse holds the response for the GetDesiredClientState API request
message GetDesiredClientStateResponse{
    // Note: kubeResources name is reserved till 4.20
    reserved 1;
    // desiredStateHash is a hash for representing the latest desired state corresponding to 
    // this message
    string desiredStateHash = 2;
    // clientOperatorChannel indicate the desired channel that should be used for the 
    // the client operator
    string clientOperatorChannel = 3;
    // minatenanceMode indicates that the target client should consider itself in maintenance mode
    bool maintenanceMode = 4;
    // mirrorEnabled indicates that the target client should consider itself enabled for mirroring
    bool mirrorEnabled = 5;
    // kubeObjects holds the definition and metadata for all kube objects to be reconciled
    // by the client operator
    repeated KubeObject kubeObjects = 6;
    // rbdDriverRequirements holds the rbd driver desired state that has to be updated by
    // the client operator, its an optional response   
    optional RbdDriverRequirements rbdDriverRequirements = 7;
    optional CephFsDriverRequirements CephFsDriverRequirements = 8;
    optional NfsDriverRequirements NfsDriverRequirements = 9;
    // externalEndpointConfig lists external endpoints (e.g. NooBaa S3, NooBaa IAM, RGW S3 etc) that the
    // client may expose via a reverse proxy for the Object Browser
    // if empty or unset, the client should configure no proxy locations for external endpoints
    repeated ExternalEndpointConfig externalEndpointConfig = 10;
}


// OffboardConsumerRequest holds the required information to delete the StorageConsumer CR on the storage provider cluster.
message OffboardConsumerRequest{
    // K8s UID (UUID) of the consumer cluster
    string storageConsumerUUID = 1;
}

// OffboardConsumerResponse holds the response for the OffboardConsumer API request
message OffboardConsumerResponse{

}

message ReportStatusRequest{
    string storageConsumerUUID = 1;
    string clientPlatformVersion = 2;
    string clientOperatorVersion = 3;
    // clusterID is the id of the openshift cluster
    string clusterID = 4;
    // clusterName is the name of the openshift cluster
    string clusterName = 5;
    // clientName is the name of the connected storageclient
    string clientName = 6;
    // storageQuotaUtilizationRatio is the ratio of utilized quota of connected client
    double storageQuotaUtilizationRatio = 7;
    // clientID is the k8s UID of storageClient
    string clientID = 8;
    // ocs-client-operator deployed namespace
    string clientOperatorNamespace = 9;

}

message ReportStatusResponse{
    string desiredClientOperatorChannel = 1;
    // Contains hash of desired config
    string desiredConfigHash = 2;
}

// PeerStorageClusterRequest holds the required information to Peer to remote StorageCluster
message PeerStorageClusterRequest{
    // onboardingToken authenticates the StorageCluster
    string onboardingToken = 1;
    // storageClusterUID is the k8s UID of the StorageCluster in the same namespace
    string storageClusterUID = 2;
}

// PeerStorageClusterResponse holds the response for OnboardStorageClusterPeer API request
message PeerStorageClusterResponse{}

message RequestMaintenanceModeRequest{
  // K8s UID (UUID) of the consumer cluster.
  string storageConsumerUUID = 1;

  bool enable = 2;
}

message RequestMaintenanceModeResponse{}

// StorageClientsInfoRequest holds the required information to get Peer Client Info
message StorageClientsInfoRequest{
  // storageClusterUID is the k8s UID of the peer StorageCluster
  string storageClusterUID = 1;
  // clientID is the k8s UID of the peer StorageConsumers
  repeated string clientIDs = 2;
}

message ClientInfo{
  // clientID holds a unique id that identifies an DF storage client
  string clientID = 1;
  // radosNamespace is the RBD radosnamespace name that is used by the client
  string radosNamespace = 2;
  // rbdStorageID is a unique identifier for the RBD storage that is used by the client
  string rbdStorageID = 3;
  // clientProfiles hold the CSI operator ClientProfile names utilized by the client
  map<string,string> clientProfiles = 4;
}

enum ErrorCode{
  NotFound = 0;
  Internal = 1;
  InvalidArgument = 2;
}

message StorageClientInfoError {
    ErrorCode code = 1;
    string message = 2;
    string clientID = 3;
}

// StorageClientsInfoResponse holds the response for GetClientInfo API request
message StorageClientsInfoResponse{
  repeated ClientInfo clientsInfo = 1;
  repeated StorageClientInfoError errors = 2;
}

// BlockPoolsInfoRequest holds the required information to get Peer BlockPool Info
message BlockPoolsInfoRequest{
  // storageClusterUID is the k8s UID of the Peer StorageCluster
  string storageClusterUID = 1;
  // blockPoolNames are blockPool names requested for mirroring
  repeated string blockPoolNames = 2;
}

message BlockPoolInfoError {
  ErrorCode code = 1;
  string message = 2;
  string blockPoolName =3;
}

message BlockPoolInfo{
  string blockPoolName = 1;
  string mirroringToken = 2;
  string blockPoolID = 3;
}

// BlockPoolsInfoResponse holds the response for GetBlockPoolInfo API request
message BlockPoolsInfoResponse{
  repeated BlockPoolInfo blockPoolsInfo = 1;
  repeated BlockPoolInfoError errors = 2;
}

enum NotifyReason{
  UNKNOWN = 0; // default (must be added according to proto3 documentation)
  OBC_CREATED = 1;
  OBC_DELETED = 2;
}

// NotifyRequest holds the required information for Notify API request
message NotifyRequest {
  // K8s UID (UUID) of the consumer cluster.
  string storageConsumerUUID = 1;
  NotifyReason reason = 2;
  // payload holds the serialized bytes - depends on the reason
  bytes payload  = 3;
}

// NotifyResponse holds the response for the Notify API request
message NotifyResponse {

}
